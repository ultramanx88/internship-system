import { NextResponse } from 'next/server';
import { z } from 'zod';
import bcrypt from 'bcryptjs';
import { prisma } from '@/lib/prisma';

const verifySchema = z.object({
  identifier: z.string().min(1, '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏ ID ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏µ‡πÄ‡∏°‡∏•'),
  password: z.string().min(1, '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô'),
});

export async function POST(request: Request) {
  try {
    console.log('üîç Auth verify API called');
    
    const body = await request.json();
    console.log('üìù Request body:', { identifier: body.identifier, password: '***' });
    
    const result = verifySchema.safeParse(body);

    if (!result.success) {
      console.log('‚ùå Validation failed:', result.error.flatten());
      return NextResponse.json(
        { message: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á', errors: result.error.flatten() },
        { status: 400 }
      );
    }

    const { identifier, password } = result.data;

    // Test database connection
    try {
      await prisma.$connect();
      console.log('‚úÖ Database connected');
    } catch (dbError) {
      console.error('‚ùå Database connection failed:', dbError);
      return NextResponse.json(
        { message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ' },
        { status: 500 }
      );
    }

    // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å ID ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏µ‡πÄ‡∏°‡∏•
    console.log('üîç Searching for user:', identifier);
    const user = await prisma.user.findFirst({
      where: {
        OR: [
          { id: identifier },
          { email: identifier }
        ]
      },
      select: {
        id: true,
        email: true,
        name: true,
        password: true,
        roles: true
      }
    });

    if (!user) {
      console.log('‚ùå User not found:', identifier);
      return NextResponse.json(
        { message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ô‡∏µ‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö' },
        { status: 401 }
      );
    }

    console.log('‚úÖ User found:', user.name, user.email);

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô
    const isPasswordValid = await bcrypt.compare(password, user.password);
    console.log('üîê Password valid:', isPasswordValid);
    
    if (!isPasswordValid) {
      return NextResponse.json(
        { message: '‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á' },
        { status: 401 }
      );
    }

    // ‡πÅ‡∏õ‡∏•‡∏á roles ‡∏à‡∏≤‡∏Å JSON string ‡πÄ‡∏õ‡πá‡∏ô array
    let userRoles;
    try {
      userRoles = JSON.parse(user.roles);
      console.log('üë§ User roles:', userRoles);
    } catch (roleError) {
      console.error('‚ùå Failed to parse roles:', user.roles, roleError);
      return NextResponse.json(
        { message: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ö‡∏ó‡∏ö‡∏≤‡∏ó‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á' },
        { status: 500 }
      );
    }

    // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡∏±‡∏ö (‡πÑ‡∏°‡πà‡∏£‡∏ß‡∏°‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô)
    const authUser = {
      id: user.id,
      email: user.email,
      name: user.name,
      roles: userRoles
    };

    console.log('‚úÖ Authentication successful for:', user.name);
    return NextResponse.json({
      message: '‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
      user: authUser
    });

  } catch (error) {
    console.error('‚ùå Verify error:', error);
    return NextResponse.json(
      { 
        message: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
        error: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}